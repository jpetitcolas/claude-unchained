#!/bin/bash
# Claude Code Isolated - Wrapper script for containerized Claude Code
# Usage: ./claude-isolated [claude arguments...]

set -e

# Ensure we have a workspace to mount
if [ ! -d "$(pwd)" ]; then
    echo "Error: Current directory does not exist"
    exit 1
fi

# Detect if running in interactive terminal
if [ -t 0 ] && [ -t 1 ]; then
    INTERACTIVE_FLAGS="-it"
else
    INTERACTIVE_FLAGS=""
fi

# Run Claude Code in isolated container with Docker-in-Docker
# --privileged is required for Docker daemon to run inside container
# --hostname=claude-isolated provides consistent identity across container runs
# Mount workspace at same path as host so Claude can track sessions per project
# Mount host .claude directory directly (sessions, todos, deny rules all work)
# Each container instance runs its own Docker daemon with isolated network/ports
# Pass through TERM and COLORTERM for proper color support
# Use --permission-mode bypassPermissions for YOLO mode (no prompts)
WORKSPACE_PATH="$(pwd)"

# Load configuration from files (local overrides global)
# Priority: local config > global config
CONFIG_WHITELIST_DOMAINS=""
CONFIG_SSH_KEY_PATH=""
CONFIG_VOLUMES=""
CONFIG_GH_TOKEN=""
CONFIG_GH_USER=""

# Function to merge config from a JSON file
load_config() {
    local config_file="$1"
    if [ -f "$config_file" ] && command -v jq >/dev/null 2>&1; then
        # Read whitelisted domains
        local domains=$(jq -r '.networking.whitelisted_domains[]? // empty' "$config_file" 2>/dev/null | tr '\n' ' ')
        if [ -n "$domains" ]; then
            CONFIG_WHITELIST_DOMAINS="$CONFIG_WHITELIST_DOMAINS $domains"
        fi

        # Read SSH key path
        local ssh_key=$(jq -r '.ssh.keyPath? // empty' "$config_file" 2>/dev/null)
        if [ -n "$ssh_key" ]; then
            CONFIG_SSH_KEY_PATH="$ssh_key"
        fi

        # Read GitHub token and user
        local gh_token=$(jq -r '.github.token? // empty' "$config_file" 2>/dev/null)
        if [ -n "$gh_token" ]; then
            CONFIG_GH_TOKEN="$gh_token"
        fi

        local gh_user=$(jq -r '.github.user? // empty' "$config_file" 2>/dev/null)
        if [ -n "$gh_user" ]; then
            CONFIG_GH_USER="$gh_user"
        fi

        # Read volumes
        local volumes=$(jq -r '.volumes[]? | "\(.host):\(.container)" + (if .readonly then ":ro" else "" end)' "$config_file" 2>/dev/null | tr '\n' ' ')
        if [ -n "$volumes" ]; then
            CONFIG_VOLUMES="$CONFIG_VOLUMES $volumes"
        fi
    fi
}

# Load configs in priority order (later configs override earlier ones):
# 1. Global base config (lowest priority)
# 2. Global local config with secrets
# 3. Project base config (can be committed)
# 4. Project local config with secrets (highest priority)
load_config "$HOME/.claude-unchained.config.json"
load_config "$HOME/.claude-unchained.config.local.json"
load_config "./.claude-unchained.config.json"
load_config "./.claude-unchained.config.local.json"

# Parse volumes from config
# Format: space-separated mount specs (e.g., "/host/path:/container/path:ro /another:/path")
EXTRA_MOUNT_FLAGS=""
for mount in $CONFIG_VOLUMES; do
    if [ -n "$mount" ]; then
        EXTRA_MOUNT_FLAGS="$EXTRA_MOUNT_FLAGS -v $mount"
    fi
done

# Mount SSH key if specified in config
SSH_MOUNT_FLAGS=""
if [ -n "$CONFIG_SSH_KEY_PATH" ]; then
    # Expand tilde in path
    SSH_KEY_BASE="${CONFIG_SSH_KEY_PATH/#\~/$HOME}"

    if [ -f "$SSH_KEY_BASE" ]; then
        # Extract just the filename from the path for mounting
        SSH_KEY_NAME=$(basename "$SSH_KEY_BASE")
        SSH_MOUNT_FLAGS="-v $SSH_KEY_BASE:/home/claude/.ssh/$SSH_KEY_NAME:ro"
        if [ -f "$SSH_KEY_BASE.pub" ]; then
            SSH_MOUNT_FLAGS="$SSH_MOUNT_FLAGS -v $SSH_KEY_BASE.pub:/home/claude/.ssh/$SSH_KEY_NAME.pub:ro"
        fi
    fi
fi

# Mount GitHub CLI config
GH_CONFIG_MOUNT=""
GH_CONFIG_CLEANUP=""

if [ -n "$CONFIG_GH_TOKEN" ]; then
    # Generate temporary gh config directory from JSON config
    # User field is optional - use placeholder if not provided
    GH_USER="${CONFIG_GH_USER:-user}"
    GH_CONFIG_DIR=$(mktemp -d)
    GH_CONFIG_CLEANUP="$GH_CONFIG_DIR"

    # Create gh config directory structure
    mkdir -p "$GH_CONFIG_DIR"
    cat > "$GH_CONFIG_DIR/hosts.yml" << EOF
github.com:
    user: $GH_USER
    oauth_token: $CONFIG_GH_TOKEN
    git_protocol: ssh
EOF
    # Mount as writable - gh CLI needs to write during migration
    # The container is ephemeral anyway, so changes are discarded on exit
    GH_CONFIG_MOUNT="-v $GH_CONFIG_DIR:/home/claude/.config/gh"
elif [ -f "$HOME/.config/gh/hosts.yml" ]; then
    # Fall back to global gh config (writable to allow gh CLI migration)
    GH_CONFIG_MOUNT="-v $HOME/.config/gh:/home/claude/.config/gh"
fi

# Build the docker command as an array to handle spaces correctly
DOCKER_CMD=(
    docker run --rm $INTERACTIVE_FLAGS
    --privileged
    --hostname=claude-isolated
    -e CLAUDE_CONFIG_DIR=/home/claude/.claude
    -e "CLAUDE_UNCHAINED_WHITELIST_DOMAINS=${CONFIG_WHITELIST_DOMAINS}"
    -e "TERM=${TERM:-xterm-256color}"
    -e "COLORTERM=${COLORTERM:-truecolor}"
)

# Add GIT_SSH_COMMAND if SSH key is configured
if [ -n "$CONFIG_SSH_KEY_PATH" ] && [ -f "$SSH_KEY_BASE" ]; then
    DOCKER_CMD+=(-e "GIT_SSH_COMMAND=ssh -i /home/claude/.ssh/$SSH_KEY_NAME -o IdentitiesOnly=yes")
fi

# Add remaining arguments
DOCKER_CMD+=(
    -w "$WORKSPACE_PATH"
    -v "$WORKSPACE_PATH:$WORKSPACE_PATH"
    -v "$HOME/.claude:/home/claude/.claude"
    -v "$HOME/.gitconfig:/home/claude/.gitconfig:ro"
    -v claude-pnpm-store:/home/claude/.local/share/pnpm/store
)

# Add dynamic mount flags
for flag in $SSH_MOUNT_FLAGS $GH_CONFIG_MOUNT $EXTRA_MOUNT_FLAGS; do
    [ -n "$flag" ] && DOCKER_CMD+=($flag)
done

# Add image and command
DOCKER_CMD+=(claude-isolated --permission-mode bypassPermissions "$@")

# Execute the command
"${DOCKER_CMD[@]}"

# Cleanup temporary files
if [ -n "$GH_CONFIG_CLEANUP" ]; then
    rm -rf "$GH_CONFIG_CLEANUP"
fi
