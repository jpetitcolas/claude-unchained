#!/bin/bash
# Claude Code Unchained - Wrapper script for containerized Claude Code
# Usage: ./claude-unchained [claude arguments...]

set -e

# Configuration constants
readonly CONTAINER_USER="claude"
readonly CONTAINER_HOME="/home/claude"
readonly CONTAINER_CLAUDE_DIR="${CONTAINER_HOME}/.claude"
readonly CONTAINER_IMAGE="claude-unchained"
readonly DEFAULT_TERM="xterm-256color"
readonly DEFAULT_COLORTERM="truecolor"
readonly PNPM_VOLUME_NAME="claude-pnpm-store"

# Ensure we have a workspace to mount
if [ ! -d "$(pwd)" ]; then
    echo "Error: Current directory does not exist"
    exit 1
fi

# Detect if running in interactive terminal
if [ -t 0 ] && [ -t 1 ]; then
    INTERACTIVE_FLAGS="-it"
else
    INTERACTIVE_FLAGS=""
fi

# Run Claude Code in isolated container with Docker-in-Docker
# --privileged is required for Docker daemon to run inside container
# --hostname=claude-unchained provides consistent identity across container runs
# Mount workspace at same path as host so Claude can track sessions per project
# Mount host .claude directory directly (sessions, todos, deny rules all work)
# Each container instance runs its own Docker daemon with isolated network/ports
# Pass through TERM and COLORTERM for proper color support
# Use --permission-mode bypassPermissions for YOLO mode (no prompts)
WORKSPACE_PATH="$(pwd)"

# Configuration variables (populated from JSON config files)
CONFIG_WHITELIST_DOMAINS=""
CONFIG_SSH_KEY_PATH=""
CONFIG_VOLUMES=""
CONFIG_GH_TOKEN=""
CONFIG_GH_USER=""

# Helper to extract a single value from JSON config
extract_config_value() {
    local config_file="$1"
    local jq_query="$2"
    jq -r "$jq_query // empty" "$config_file" 2>/dev/null
}

# Helper to extract array values from JSON config
extract_config_array() {
    local config_file="$1"
    local jq_query="$2"
    jq -r "$jq_query" "$config_file" 2>/dev/null | tr '\n' ' '
}

# Function to merge config from a JSON file
load_config() {
    local config_file="$1"

    # Skip if file doesn't exist
    if [ ! -f "$config_file" ]; then
        return 0
    fi

    # Skip if jq is not available
    if ! command -v jq >/dev/null 2>&1; then
        return 0
    fi

    # Read whitelisted domains
    local domains=$(extract_config_array "$config_file" '.networking.whitelisted_domains[]? // empty')
    [ -n "$domains" ] && CONFIG_WHITELIST_DOMAINS="$CONFIG_WHITELIST_DOMAINS $domains"

    # Read SSH key path
    local ssh_key=$(extract_config_value "$config_file" '.ssh.keyPath')
    [ -n "$ssh_key" ] && CONFIG_SSH_KEY_PATH="$ssh_key"

    # Read GitHub token and user
    local gh_token=$(extract_config_value "$config_file" '.github.token')
    [ -n "$gh_token" ] && CONFIG_GH_TOKEN="$gh_token"

    local gh_user=$(extract_config_value "$config_file" '.github.user')
    [ -n "$gh_user" ] && CONFIG_GH_USER="$gh_user"

    # Read volumes
    local volumes=$(jq -r '.volumes[]? | "\(.host):\(.container)" + (if .readonly then ":ro" else "" end)' "$config_file" 2>/dev/null | tr '\n' ' ')
    [ -n "$volumes" ] && CONFIG_VOLUMES="$CONFIG_VOLUMES $volumes"

    return 0
}

# Load configs in priority order (later configs override earlier ones):
# 1. Global base config (lowest priority)
# 2. Global local config with secrets
# 3. Project base config (can be committed)
# 4. Project local config with secrets (highest priority)
load_config "$HOME/.claude-unchained.config.json"
load_config "$HOME/.claude-unchained.config.local.json"
load_config "./.claude-unchained.config.json"
load_config "./.claude-unchained.config.local.json"

# Expand tilde in path
expand_path() {
    local path="$1"
    echo "${path/#\~/$HOME}"
}

# Build SSH mount flags and return mount specs
# Returns two values: mount_flags and key_name (separated by newline)
build_ssh_mount_flags() {

    if [ -z "$CONFIG_SSH_KEY_PATH" ]; then
        return 0
    fi

    local key_path=$(expand_path "$CONFIG_SSH_KEY_PATH")

    # Check if key file exists
    if [ ! -f "$key_path" ]; then
        return 0
    fi

    local key_name=$(basename "$key_path")
    local mount_flags="-v $key_path:$CONTAINER_HOME/.ssh/$key_name:ro"

    # Add public key if it exists
    if [ -f "$key_path.pub" ]; then
        mount_flags="$mount_flags -v $key_path.pub:$CONTAINER_HOME/.ssh/$key_name.pub:ro"
    fi

    # Output both values (for consumption by caller)
    echo "$mount_flags"
    echo "$key_name"
}

# Set up GitHub CLI config from token
setup_gh_config_from_token() {
    local temp_dir=$(mktemp -d)
    local gh_user="${CONFIG_GH_USER:-user}"

    cat > "$temp_dir/hosts.yml" << EOF
github.com:
    user: $gh_user
    oauth_token: $CONFIG_GH_TOKEN
    git_protocol: ssh
EOF

    echo "$temp_dir"
}

# Build GitHub CLI config mount flags
# Returns two values: mount_flags and cleanup_dir (separated by newline)
setup_gh_config_mount() {
    if [ -n "$CONFIG_GH_TOKEN" ]; then
        # Generate temporary gh config from token
        local gh_config_dir=$(setup_gh_config_from_token)
        echo "-v $gh_config_dir:$CONTAINER_HOME/.config/gh"
        echo "$gh_config_dir"
    elif [ -f "$HOME/.config/gh/hosts.yml" ]; then
        # Fall back to global gh config (writable to allow gh CLI migration)
        echo "-v $HOME/.config/gh:$CONTAINER_HOME/.config/gh"
        echo ""
    fi
}

# Parse volumes from config and build mount flags
build_extra_mount_flags() {
    local mount_flags=""

    for mount_spec in $CONFIG_VOLUMES; do
        [ -n "$mount_spec" ] && mount_flags="$mount_flags -v $mount_spec"
    done

    echo "$mount_flags"
}

# Set up SSH mounts
SSH_MOUNT_OUTPUT=$(build_ssh_mount_flags)
SSH_MOUNT_FLAGS=$(echo "$SSH_MOUNT_OUTPUT" | head -n 1)
SSH_KEY_NAME=$(echo "$SSH_MOUNT_OUTPUT" | tail -n 1)

# Set up GitHub CLI config
GH_CONFIG_OUTPUT=$(setup_gh_config_mount)
GH_CONFIG_MOUNT=$(echo "$GH_CONFIG_OUTPUT" | head -n 1)
GH_CONFIG_CLEANUP=$(echo "$GH_CONFIG_OUTPUT" | tail -n 1)

# Parse extra volume mounts
EXTRA_MOUNT_FLAGS=$(build_extra_mount_flags)

# Build the docker command as an array to handle spaces correctly
DOCKER_CMD=(docker run --rm)

# Add interactive flags if running in a TTY
if [ -n "$INTERACTIVE_FLAGS" ]; then
    DOCKER_CMD+=(-i -t)
fi

DOCKER_CMD+=(
    --privileged
    --hostname=claude-unchained
    -e "CLAUDE_UNCHAINED_WHITELIST_DOMAINS=${CONFIG_WHITELIST_DOMAINS}"
    -e "HOST_HOME=$HOME"
    -e "TERM=${TERM:-$DEFAULT_TERM}"
    -e "COLORTERM=${COLORTERM:-$DEFAULT_COLORTERM}"
)

# Add GIT_SSH_COMMAND if SSH key is configured
if [ -n "$SSH_KEY_NAME" ]; then
    DOCKER_CMD+=(-e "GIT_SSH_COMMAND=ssh -i $CONTAINER_HOME/.ssh/$SSH_KEY_NAME -o IdentitiesOnly=yes")
fi

# Add remaining arguments
DOCKER_CMD+=(
    -w "$WORKSPACE_PATH"
    -v "$WORKSPACE_PATH:$WORKSPACE_PATH"
    -v "$HOME/.claude:$CONTAINER_CLAUDE_DIR"
    -v "$HOME/.claude.json:$CONTAINER_HOME/.claude.json"
    -v "$HOME/.gitconfig:$CONTAINER_HOME/.gitconfig:ro"
    -v "$PNPM_VOLUME_NAME:$CONTAINER_HOME/.local/share/pnpm/store"
)

# Add dynamic mount flags
for mount_spec in $SSH_MOUNT_FLAGS $GH_CONFIG_MOUNT $EXTRA_MOUNT_FLAGS; do
    [ -n "$mount_spec" ] && DOCKER_CMD+=($mount_spec)
done

# Add image and command
DOCKER_CMD+=("$CONTAINER_IMAGE" --permission-mode bypassPermissions "$@")

# Execute the command
"${DOCKER_CMD[@]}"
EXIT_CODE=$?

# Cleanup temporary files (only if it's a valid path starting with /)
[ -n "$GH_CONFIG_CLEANUP" ] && [[ "$GH_CONFIG_CLEANUP" == /* ]] && rm -rf "$GH_CONFIG_CLEANUP"

# Exit with docker's exit code
exit $EXIT_CODE
