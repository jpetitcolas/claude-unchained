#!/bin/bash
# Entrypoint script for Claude Code isolated container
# Uses SNI proxy (nginx) for domain-based filtering instead of IP whitelisting

# Configuration constants
readonly DNS_PORT=53
readonly HTTP_PORT=80
readonly HTTPS_PORT=443
readonly SSH_PORT=22
readonly SNI_PROXY_PORT=8443
readonly DOCKER_STARTUP_TIMEOUT=30
readonly SNI_MAP_CONF="/etc/nginx/stream.d/sni-map.conf"

# Cleanup on exit or interrupt
cleanup() {
    nginx -s quit 2>/dev/null || true
}
trap cleanup EXIT SIGTERM SIGINT

# Hardcoded whitelist of allowed domains (minimal set)
WHITELISTED_DOMAINS=(
    # Claude Code
    "code.claude.com"
    "api.anthropic.com"
    "platform.claude.com"
    "claude.ai"
    # GitHub
    "github.com"
    "ssh.github.com"
    "raw.githubusercontent.com"
    "api.github.com"
    # Docker Hub - Official allowlist from https://docs.docker.com/desktop/setup/allow-list/
    "auth.docker.io"
    "login.docker.com"
    "auth.docker.com"
    "hub.docker.com"
    "registry-1.docker.io"
    "production.cloudflare.docker.com"
    "docker-images-prod.6aa30f8b08e16409b46e0173d6de2f56.r2.cloudflarestorage.com"
    "desktop.docker.com"
    "api.docker.com"
    # npm registry - required for MCP plugins installed via npx
    "registry.npmjs.org"
)

# Add extra domains from environment variable if set
add_extra_whitelisted_domains() {
    [ -z "$CLAUDE_UNCHAINED_WHITELIST_DOMAINS" ] && return 0

    set -f  # Disable glob expansion
    local -a extra_domains=($CLAUDE_UNCHAINED_WHITELIST_DOMAINS)
    set +f

    local added=0
    for domain in "${extra_domains[@]}"; do
        # Validate domain format (alphanumeric, dots, hyphens only)
        if [[ "$domain" =~ ^[a-zA-Z0-9]([a-zA-Z0-9.-]*[a-zA-Z0-9])?$ ]]; then
            WHITELISTED_DOMAINS+=("$domain")
            ((added++))
        else
            echo "Warning: Invalid domain ignored: $domain" >&2
        fi
    done

    echo "Added $added extra domain(s) from config"
}

# Check if domain requires SSH access (for git operations)
is_github_domain() {
    local domain="$1"
    [ "$domain" = "github.com" ] || [ "$domain" = "ssh.github.com" ]
}

# Escape domain for use in nginx regex (escape dots)
escape_domain_for_regex() {
    local domain="$1"
    echo "$domain" | sed 's/\./\\./g'
}

# Generate SNI domain map (the only dynamic part of nginx config)
generate_sni_domain_map() {
    cat > "$SNI_MAP_CONF" << 'MAP_HEADER'
# SNI hostname to upstream mapping
# Auto-generated by entrypoint.sh - do not edit manually

map $ssl_preread_server_name $sni_upstream {
    default "";
MAP_HEADER

    # Add each whitelisted domain to the map
    for domain in "${WHITELISTED_DOMAINS[@]}"; do
        local escaped=$(escape_domain_for_regex "$domain")
        echo "    ~^${escaped}\$ \$ssl_preread_server_name:443;" >> "$SNI_MAP_CONF"
    done

    echo "}" >> "$SNI_MAP_CONF"

    echo "Generated SNI domain map with ${#WHITELISTED_DOMAINS[@]} whitelisted domains"
}

# Start nginx SNI proxy
start_sni_proxy() {
    echo "Starting SNI proxy..."

    # Generate the dynamic domain map (static configs are COPYed in Dockerfile)
    generate_sni_domain_map

    # Test nginx configuration
    local nginx_test_output
    if ! nginx_test_output=$(nginx -t 2>&1); then
        echo "âŒ ERROR: Nginx configuration test failed" >&2
        echo "$nginx_test_output" >&2
        echo "  Check config: cat /etc/nginx/nginx.conf" >&2
        return 1
    fi

    # Start nginx
    if ! nginx; then
        echo "ERROR: Failed to start nginx" >&2
        return 1
    fi
    echo "SNI proxy started on port $SNI_PROXY_PORT"
}

# Initialize iptables firewall with SNI proxy redirect
initialize_firewall() {
    echo "Setting up network firewall with SNI proxy..."

    # Disable IPv6 to prevent firewall bypass (we only proxy IPv4)
    if ! sysctl -w net.ipv6.conf.all.disable_ipv6=1 >/dev/null 2>&1; then
        echo "âš ï¸  Warning: Could not disable IPv6 (may not be available)"
    fi

    # Flush existing rules
    iptables -t nat -F OUTPUT 2>/dev/null || true
    iptables -F OUTPUT 2>/dev/null || true
    iptables -F INPUT 2>/dev/null || true

    # Set default policies
    iptables -P INPUT ACCEPT
    iptables -P OUTPUT DROP
    iptables -P FORWARD DROP

    # Allow loopback (required for SNI proxy communication)
    iptables -A OUTPUT -o lo -j ACCEPT

    # Allow DNS (required for domain resolution)
    iptables -A OUTPUT -p udp --dport "$DNS_PORT" -j ACCEPT
    iptables -A OUTPUT -p tcp --dport "$DNS_PORT" -j ACCEPT

    # Allow established connections (for proxied connections)
    iptables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT

    # Redirect all outbound HTTPS traffic to SNI proxy (except root/nginx)
    # This captures traffic from non-root processes and sends it through the proxy
    # Root is excluded so nginx can forward traffic to upstream servers
    iptables -t nat -A OUTPUT -p tcp --dport "$HTTPS_PORT" -m owner ! --uid-owner root -j REDIRECT --to-port "$SNI_PROXY_PORT"

    # Allow connections to SNI proxy port (redirected traffic lands here)
    iptables -A OUTPUT -p tcp --dport "$SNI_PROXY_PORT" -j ACCEPT

    # Allow root (nginx) to make outbound HTTPS connections to upstream servers
    iptables -A OUTPUT -p tcp --dport "$HTTPS_PORT" -m owner --uid-owner root -j ACCEPT

    # HTTP is blocked - no SNI filtering possible for unencrypted traffic
    # Most services use HTTPS anyway; HTTP would bypass domain whitelist

    # Allow SSH to GitHub for git operations
    local github_ips ssh_github_ips
    github_ips=$(dig +short github.com A 2>/dev/null)
    ssh_github_ips=$(dig +short ssh.github.com A 2>/dev/null)

    if [ -z "$github_ips" ] && [ -z "$ssh_github_ips" ]; then
        echo "âš ï¸  Warning: Could not resolve GitHub IPs for SSH whitelist"
    else
        for ip in $github_ips; do
            iptables -A OUTPUT -d "$ip" -p tcp --dport "$SSH_PORT" -j ACCEPT
        done
        for ip in $ssh_github_ips; do
            iptables -A OUTPUT -d "$ip" -p tcp --dport "$SSH_PORT" -j ACCEPT
        done
    fi

    echo "Firewall configured with SNI proxy redirect"
}

# Start Docker daemon in background
start_docker_daemon() {
    echo "Starting Docker daemon..."
    dockerd --storage-driver=vfs > /var/log/docker.log 2>&1 &
    echo $!
}

# Wait for Docker daemon to become ready
wait_for_docker() {
    local timeout="$1"
    local waited=0

    echo "Waiting for Docker to be ready..."
    while ! docker info > /dev/null 2>&1; do
        if [ "$waited" -ge "$timeout" ]; then
            echo ""
            echo "âŒ ERROR: Docker daemon failed to start within ${timeout}s" >&2
            echo "  Check logs: cat /var/log/docker.log" >&2
            return 1
        fi
        printf "  â³ Waiting for Docker... (%ds/%ds)\r" "$waited" "$timeout"
        sleep 1
        waited=$((waited + 1))
    done
    echo ""
    echo "Docker daemon ready!"
}

# Set up SSH directory with correct permissions
setup_ssh_directory() {
    local ssh_key_path="$1"
    local ssh_dir="$2"

    [ ! -f "$ssh_key_path" ] && return 0

    mkdir -p "$ssh_dir"
    chown claude:claude "$ssh_dir" 2>/dev/null || true
    chmod 700 "$ssh_dir" 2>/dev/null || true
}

# Create symlink from host's .claude path to /home/claude/.claude
setup_host_home_symlink() {
    [ -z "$HOST_HOME" ] && return 0
    [ "$HOST_HOME" = "/home/claude" ] && return 0

    local host_claude_dir="$HOST_HOME/.claude"
    echo "Creating symlink: $host_claude_dir -> /home/claude/.claude"
    mkdir -p "$HOST_HOME" 2>/dev/null || true
    ln -sf /home/claude/.claude "$host_claude_dir" 2>/dev/null || true
}

# Print whitelisted domains for user visibility
print_whitelisted_domains() {
    echo "Whitelisted domains:"
    for domain in "${WHITELISTED_DOMAINS[@]}"; do
        echo "  - $domain"
    done
}

# Main execution
echo "ðŸš€ Starting Claude Code container..."
echo ""

add_extra_whitelisted_domains

print_whitelisted_domains
echo ""

# Start SNI proxy first (before firewall redirects traffic to it)
if ! start_sni_proxy; then
    echo "âŒ Failed to start SNI proxy"
    exit 1
fi

# Set up firewall with SNI proxy redirect
initialize_firewall

echo ""

# Ensure .claude directory is writable by claude user
chown -R claude:claude /home/claude/.claude 2>/dev/null || true

# Fix SSH permissions
setup_ssh_directory "/home/claude/.ssh/id_ed25519" "/home/claude/.ssh"

# Create symlink from host home path to allow plugin paths to resolve
setup_host_home_symlink

# Start Docker daemon in background for Docker-in-Docker support
start_docker_daemon
if ! wait_for_docker "$DOCKER_STARTUP_TIMEOUT"; then
    exit 1
fi

echo ""
echo "âœ… Container ready"
echo ""

# Switch to claude user and execute the command passed to the container
exec gosu claude env HOME=/home/claude "$@"
